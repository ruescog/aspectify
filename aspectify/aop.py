# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_aop.ipynb.

# %% auto 0
__all__ = ['is_detectable', 'advice', 'Aspect']

# %% ../nbs/00_aop.ipynb 3
import re

# %% ../nbs/00_aop.ipynb 4
def is_detectable(name, obj):
    """
    Determines when an object is potentially detectable to add an aspect to it.

    Params:
    name: str ; The name of the object.
    obj: object ; The builded object --generaly a class--.

    Returns:
    b: boolean ; Whether the `obj` object (so called `name`) is detectable via AOP or not.
    """
    return (name not in ["get_ipython", "exit", "quit", "open"]
            and not isinstance(obj, Aspect)
            and isinstance(obj, type) # it must be a type (a class)
            and callable(obj)
            )

# %% ../nbs/00_aop.ipynb 5
def advice(moment, todo):
    """
    Add an advice to a particular function.

    Params:
    moment: str ; One of 'before', 'around', 'after_returning', 'after_throwing' or 'after'. See the documentation for more information.
    todo: funtion ; What to do at the selected moment.

    Returns:
    dec: function ; The modified function.
    """
    def dec(method):
        def inner(*args, **kwargs):
            todo_args = args[1:] # discards the 0-index argument, which is the object itself
            if moment not in ["before", "around", "after_returning", "after_throwing", "after"]:
                raise Exception(f"Moment {moment} is not defined.")

            try:
                if moment == "before": todo(*todo_args, **kwargs) # returned value is lost
                result = todo(*todo_args, **kwargs) if moment == "around" else method(*args, **kwargs)
                if moment in ["after_returning", "after"]: todo(*todo_args, **kwargs)
                return result

            except Exception as e:
                if moment in ["after_throwing", "after"]: todo([e, *todo_args], **kwargs)
                raise e

        return inner
    return dec

# %% ../nbs/00_aop.ipynb 6
class Aspect():
    """
    Defines a complete aspect.
    """
    def __init__(self, name):
        """
        Constructs a new aspect.

        Params:
        name: str ; The aspect name.

        Returns:
        None
        """
        self.name = name
        self.before = None
        self.around = None
        self.after_returning = None
        self.after_throwing = None
        self.after = None

    # POINTCUT
    def create_pointcut(self, objects, pattern, logging = True):
        """
        Creates a new pointcut associated with the aspect.

        Params:
        classes: list ; All the classes to which the aspect can be added. See the documentation for more information.
        pattern: str ; The pattern (string that defines a regular expression) used to select the methods to be added the aspect.
        logging: bool = True ; Whether to log the captured methods with the `PointCut`.

        Returns:
        None
        """
        pattern = re.compile(pattern)

        for name, _object in objects:
            if is_detectable(name, _object):
                for method_name in dir(_object):
                    if "__" in method_name: continue
                    
                    full_method_name = str(_object.__module__) + "." + str(_object.__qualname__) + "." + method_name
                    if pattern.fullmatch(full_method_name):
                        # logs the method if requested
                        if logging: message = "Captured method: " + full_method_name
                        
                        # gets the method
                        method = getattr(_object, method_name)

                        # modifies it
                        if self.around: method = advice("around", self.around)(method) # we need to add the around modification first. If not, it will overwrite the other methods
                        if self.before: method = advice("before", self.before)(method)
                        if self.after_returning: method = advice("after_returning", self.after_returning)(method)
                        if self.after_throwing: method = advice("after_throwing", self.after_throwing)(method)
                        if self.after: method = advice("after", self.after)(method)

                        # saves it
                        try:
                            setattr(_object, method_name, method)
                        except AttributeError as e:
                            if logging: message += "; CANNOT be modified."
                        
                        if logging: print(message)
        
        print("[WARNING]: If executed in a notebook, the cell is shown being executed, but this message proves that the execution is finished.")

    # ADVICES
    def set_before(self, function):
        """
        Determines what to do before the execution of the method.

        Params:
        function: function ; The 'to do' function in that moment.

        Returns:
        None
        """
        self.before = function
    
    def set_around(self, function):
        """
        Determines what to do instead of the execution of the method.

        Params:
        function: function ; The 'to do' function in that moment.

        Returns:
        None
        """
        self.around = function
    
    def set_after_returning(self, function):
        """
        Determines what to do after a complete execution of the method (when there are not exceptions).

        Params:
        function: function ; The 'to do' function in that moment.

        Returns:
        None
        """
        self.after_returning = function
    
    def set_after_throwing(self, function):
        """
        Determines what to do when the execution of the method raises an exception.
        
        * BEWARE! This method will not handle the exception (it will be finally raised), but it will allow you to do something when the exception is raised.

        Params:
        function: function ; The 'to do' function in that moment.

        Returns:
        None
        """
        self.after_throwing = function

    def set_after(self, function):
        """
        Determines what to do after the execution of the method. This function will be always executed after the `after_returning` and `after_throwing` functions.
        
        Params:
        function: function ; The 'to do' function in that moment.

        Returns:
        None
        """
        self.after = function
